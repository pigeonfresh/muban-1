(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{380:function(e,t,n){"use strict";n.r(t);var o=n(42),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"lifecycle"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#lifecycle"}},[e._v("#")]),e._v(" Lifecycle")]),e._v(" "),n("h2",{attrs:{id:"current-order"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#current-order"}},[e._v("#")]),e._v(" current order")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("Render component template")])]),e._v(" "),n("li",[n("p",[e._v("Init component DOM element")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("resolve props from sources")])]),e._v(" "),n("li",[n("p",[e._v("resolve refs from config > DOM")]),e._v(" "),n("ol",[n("li",[e._v("for elements/collections - query the DOM for the element(s)")]),e._v(" "),n("li",[e._v("for component bindings - create child components (recursion at step 2 above)")])])]),e._v(" "),n("li",[n("p",[e._v("watch for mutation changes in DOM to update refs or create new components (step 2 above)")])]),e._v(" "),n("li",[n("p",[e._v("make lifecycle registration active")])]),e._v(" "),n("li",[n("p",[e._v("call setup function (return bindings)")]),e._v(" "),n("ol",[n("li",[e._v("get access to props and refs")]),e._v(" "),n("li",[e._v("firing of parent callback functions won't work at this point, they are undefined")]),e._v(" "),n("li",[e._v("return binding definitions")])])]),e._v(" "),n("li",[n("p",[e._v("deactivate lifecycle registration")])]),e._v(" "),n("li",[n("p",[e._v("apply bindings")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("for elements/collections - apply DOM bindings")])]),e._v(" "),n("li",[n("p",[e._v("for component bindings - call setProps for all defined props (incl passing callback\nfunctions)")])]),e._v(" "),n("li",[n("p",[e._v("for template bindings:")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("extract data (optionally)")])]),e._v(" "),n("li",[n("p",[e._v("render template with currently active data")]),e._v(" "),n("ul",[n("li",[e._v('this will update the DOM, triggering step "iii"')])])]),e._v(" "),n("li",[n("p",[e._v('watch for new data, and re-do step "b"')])])])])])]),e._v(" "),n("li",[n("p",[e._v("call mount lifecycle")])]),e._v(" "),n("li",[n("p",[e._v("return component API (name, setProps, dispose)")])])])])]),e._v(" "),n("h2",{attrs:{id:"questions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#questions"}},[e._v("#")]),e._v(" questions")]),e._v(" "),n("ul",[n("li",[n("p",[n("strong",[e._v("Q:")]),e._v(' When can we execute "initial" callback functions to the parent')]),e._v(" "),n("p",[n("strong",[e._v("A:")]),e._v(" when setProps has been called, when applying the parent bindings, but its parent is not yet\nfully constructed")]),e._v(" "),n("p",[n("strong",[e._v("P:")]),e._v(" The problem with the above, is that the component is constructed when only the HTML props\nare available, but not the parent props. They come in a bit later (same frame), but it means\nthat the callback functions are not available yet in the setup function.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Q:")]),e._v(" How do we deal with props that we want to set on change, but not initially?")]),e._v(" "),n("p",[n("strong",[e._v("A:")]),e._v(" Find a way to get access to the props from the child component to correctly get the value in\nthe parent component when setting up the binding.")]),e._v(" "),n("p",[n("strong",[e._v("P:")]),e._v(' Props have 2 sources, the HTML and the parent component. For "data" props, the one from the\nHTML are always leading and more important, but only initially.'),n("br"),e._v("\nAfter initial setup, when interacting with the UI, things can change, and props might need to\nbe updated. The problem with this, is that the binding setup is done just once, and it should\nalready contain this prop binding, with an initial value, that might override the value from\nthe HTML. So it's key to get value of the prop that you're trying to set correct with the\ninitial value, and this initial value has to come from the child.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Q:")]),e._v(" If we expose props from child to parent, should they be reactive?\n"),n("strong",[e._v("A:")]),e._v(" Probably set them based on initial HTML props, and update them if they are accessed\nlater to reflect the correct value, but not make them reactive or update the HTML.\n"),n("strong",[e._v("P:")]),e._v(" We have a few options:")]),e._v(" "),n("ol",[n("li",[e._v("Set them based on initial HTML props")]),e._v(" "),n("li",[e._v("Update them as they are changed from the parent, but not reactive")]),e._v(" "),n("li",[e._v('Make them fully reactive as well, so they can be "watched"')]),e._v(" "),n("li",[e._v("As an addition to i or ii, also update the HTML")]),e._v(" "),n("li",[e._v("As an addition, have the props being update whenever the HTML is changed later.")])]),e._v(" "),n("p",[e._v('So the minimum we need is option "i", to sync up the correct initial state from child to parent.\nIn that scenario we would only use them to initialize our observables in the setup function.\nIf they are used in any async code (watch, callbacks), they might be incorrect / stale, so this\ncan never be used like that.')]),e._v(" "),n("p",[e._v("To support updated props in async code, we would need to update the exposed props whenever\nthe parent changes them. This used case is probably very seldom, since you could have already\nstored them locally in the setup function.")]),e._v(" "),n("p",[e._v("Making props reactive might make things more complex:")]),e._v(" "),n("ul",[n("li",[e._v("It enables 2 ways on how to listen for changes (through callbacks, and watching props)")]),e._v(" "),n("li",[e._v("It could result in infinite recursion (since bindings can set props, they would trigger the\nwatch, which could update the bindings again).")])]),e._v(" "),n("p",[e._v("So it's probably not a good idea to enable this.")]),e._v(" "),n("p",[e._v('Then we have 2 related additional options, if we should update the HTML to reflect the\ninternal state of the component, and if we should update the props when any html (through\nother means) is updated. Doing this could also result in recursion.\nBut more importantly, it would "move" the logic to keep using and mutating props in the\ncomponent, which is probably not good practice. So we\'ll ignore this for now.')])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Q:")]),e._v(' Do we need an "adopted" lifecycle hook? Would it trigger on Parent or Root adoption? Do we\nneed both? Should we "delay" the "mount" lifecycle hook? Of have "created", "mounted" and\n"adopted"?')]),e._v(" "),n("p",[n("strong",[e._v("A:")]),e._v(" Not sure, if we want to be extensive, we would have; setup(1), created(2), mounted(3) and\nadopted(4). If we want to be minimal, we would have; setup(1) and mounted(4).")]),e._v(" "),n("p",[n("strong",[e._v("P:")]),e._v(' We have 3 "moment" in the creation process of a component. Since components are created as\npart the parent creation, it\'s always "completed" earlier than the parent. This means we\nhave the moment where a component itself is created, we have the moment where its parent\nis created as well (and we receive their props, e.g. callbacks), and we have the moment the\nwhole app is created (up to the root component).\nIn most cases, we only care about the component in isolation, so we can use the first one.\nIn some cases, we might need something from the parent (e.g. calling a function passed\nthrough the props), which we can only do when the parent has been fully created.\nAnd in other cases, we need access to the root, global state, etc to be set up correctly.')]),e._v(" "),n("p",[e._v("Timing wise, these should all happen in the same frame, since the creation process is all\nsynchronous (it's just that other stuff happens in between).  We could just chose the have 1\nhook (when the root has been created), and use that for everything.")]),e._v(" "),n("p",[e._v('We already have the setup function itself, so the current "mounted" has not much additional\nvalue in its current state. Only difference is that bindings are applied,\nso manual DOM mutations will update correctly. It could be useful if we ever want to delay\nchild component creation to the "applyBindings" phase, and only have those instances\naccessible in the mount hook.')])])])])}),[],!1,null,null,null);t.default=a.exports}}]);