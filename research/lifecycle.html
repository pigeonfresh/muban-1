<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Lifecycle | Muban</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="Writing components for server-rendered HTML">
    
    <link rel="preload" href="/muban/assets/css/0.styles.fc90fd1a.css" as="style"><link rel="preload" href="/muban/assets/js/app.48237296.js" as="script"><link rel="preload" href="/muban/assets/js/2.de8cd9c4.js" as="script"><link rel="preload" href="/muban/assets/js/25.33fc5c13.js" as="script"><link rel="prefetch" href="/muban/assets/js/10.7c55db09.js"><link rel="prefetch" href="/muban/assets/js/11.a9e9df60.js"><link rel="prefetch" href="/muban/assets/js/12.e7cc04fe.js"><link rel="prefetch" href="/muban/assets/js/13.cc337c60.js"><link rel="prefetch" href="/muban/assets/js/14.c7055ebb.js"><link rel="prefetch" href="/muban/assets/js/15.1fbfe614.js"><link rel="prefetch" href="/muban/assets/js/16.7f688880.js"><link rel="prefetch" href="/muban/assets/js/17.65a01f70.js"><link rel="prefetch" href="/muban/assets/js/18.e17083c9.js"><link rel="prefetch" href="/muban/assets/js/19.9532445d.js"><link rel="prefetch" href="/muban/assets/js/20.2e603409.js"><link rel="prefetch" href="/muban/assets/js/21.ddf04c2e.js"><link rel="prefetch" href="/muban/assets/js/22.60d5b2a5.js"><link rel="prefetch" href="/muban/assets/js/23.d8a186b2.js"><link rel="prefetch" href="/muban/assets/js/24.eabdf387.js"><link rel="prefetch" href="/muban/assets/js/26.e94df976.js"><link rel="prefetch" href="/muban/assets/js/27.b0ab94dc.js"><link rel="prefetch" href="/muban/assets/js/3.4c8c1865.js"><link rel="prefetch" href="/muban/assets/js/4.af860640.js"><link rel="prefetch" href="/muban/assets/js/5.ac9e9e87.js"><link rel="prefetch" href="/muban/assets/js/6.dc00f921.js"><link rel="prefetch" href="/muban/assets/js/7.b073ec24.js"><link rel="prefetch" href="/muban/assets/js/8.44fb1b58.js"><link rel="prefetch" href="/muban/assets/js/9.2865af3c.js">
    <link rel="stylesheet" href="/muban/assets/css/0.styles.fc90fd1a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/muban/" class="home-link router-link-active"><!----> <span class="site-name">Muban</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/muban/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/muban/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/muban/api/" class="nav-link">
  Api
</a></div><div class="nav-item"><a href="/muban/research/" class="nav-link router-link-active">
  Research
</a></div> <a href="https://github.com/mubanjs/muban" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/muban/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/muban/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/muban/api/" class="nav-link">
  Api
</a></div><div class="nav-item"><a href="/muban/research/" class="nav-link router-link-active">
  Research
</a></div> <a href="https://github.com/mubanjs/muban" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/muban/research/" aria-current="page" class="sidebar-link">Research</a></li><li><a href="/muban/research/lifecycle.html" aria-current="page" class="active sidebar-link">Lifecycle</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/muban/research/lifecycle.html#current-order" class="sidebar-link">current order</a></li><li class="sidebar-sub-header"><a href="/muban/research/lifecycle.html#questions" class="sidebar-link">questions</a></li></ul></li><li><a href="/muban/research/component-props.html" class="sidebar-link">Component Props</a></li><li><a href="/muban/research/component-refs.html" class="sidebar-link">Component Refs</a></li><li><a href="/muban/research/component-dynamic-templates.html" class="sidebar-link">Dynamic Templates</a></li><li><a href="/muban/research/reactivity.html" class="sidebar-link">Exploring reactivity</a></li><li><a href="/muban/research/pure-rendering.html" class="sidebar-link">Pure rendering</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="lifecycle"><a href="#lifecycle" class="header-anchor">#</a> Lifecycle</h1> <h2 id="current-order"><a href="#current-order" class="header-anchor">#</a> current order</h2> <ol><li><p>Render component template</p></li> <li><p>Init component DOM element</p> <ol><li><p>resolve props from sources</p></li> <li><p>resolve refs from config &gt; DOM</p> <ol><li>for elements/collections - query the DOM for the element(s)</li> <li>for component bindings - create child components (recursion at step 2 above)</li></ol></li> <li><p>watch for mutation changes in DOM to update refs or create new components (step 2 above)</p></li> <li><p>make lifecycle registration active</p></li> <li><p>call setup function (return bindings)</p> <ol><li>get access to props and refs</li> <li>firing of parent callback functions won't work at this point, they are undefined</li> <li>return binding definitions</li></ol></li> <li><p>deactivate lifecycle registration</p></li> <li><p>apply bindings</p> <ol><li><p>for elements/collections - apply DOM bindings</p></li> <li><p>for component bindings - call setProps for all defined props (incl passing callback
functions)</p></li> <li><p>for template bindings:</p> <ol><li><p>extract data (optionally)</p></li> <li><p>render template with currently active data</p> <ul><li>this will update the DOM, triggering step &quot;iii&quot;</li></ul></li> <li><p>watch for new data, and re-do step &quot;b&quot;</p></li></ol></li></ol></li> <li><p>call mount lifecycle</p></li> <li><p>return component API (name, setProps, dispose)</p></li></ol></li></ol> <h2 id="questions"><a href="#questions" class="header-anchor">#</a> questions</h2> <ul><li><p><strong>Q:</strong> When can we execute &quot;initial&quot; callback functions to the parent</p> <p><strong>A:</strong> when setProps has been called, when applying the parent bindings, but its parent is not yet
fully constructed</p> <p><strong>P:</strong> The problem with the above, is that the component is constructed when only the HTML props
are available, but not the parent props. They come in a bit later (same frame), but it means
that the callback functions are not available yet in the setup function.</p></li> <li><p><strong>Q:</strong> How do we deal with props that we want to set on change, but not initially?</p> <p><strong>A:</strong> Find a way to get access to the props from the child component to correctly get the value in
the parent component when setting up the binding.</p> <p><strong>P:</strong> Props have 2 sources, the HTML and the parent component. For &quot;data&quot; props, the one from the
HTML are always leading and more important, but only initially.<br>
After initial setup, when interacting with the UI, things can change, and props might need to
be updated. The problem with this, is that the binding setup is done just once, and it should
already contain this prop binding, with an initial value, that might override the value from
the HTML. So it's key to get value of the prop that you're trying to set correct with the
initial value, and this initial value has to come from the child.</p></li> <li><p><strong>Q:</strong> If we expose props from child to parent, should they be reactive?
<strong>A:</strong> Probably set them based on initial HTML props, and update them if they are accessed
later to reflect the correct value, but not make them reactive or update the HTML.
<strong>P:</strong> We have a few options:</p> <ol><li>Set them based on initial HTML props</li> <li>Update them as they are changed from the parent, but not reactive</li> <li>Make them fully reactive as well, so they can be &quot;watched&quot;</li> <li>As an addition to i or ii, also update the HTML</li> <li>As an addition, have the props being update whenever the HTML is changed later.</li></ol> <p>So the minimum we need is option &quot;i&quot;, to sync up the correct initial state from child to parent.
In that scenario we would only use them to initialize our observables in the setup function.
If they are used in any async code (watch, callbacks), they might be incorrect / stale, so this
can never be used like that.</p> <p>To support updated props in async code, we would need to update the exposed props whenever
the parent changes them. This used case is probably very seldom, since you could have already
stored them locally in the setup function.</p> <p>Making props reactive might make things more complex:</p> <ul><li>It enables 2 ways on how to listen for changes (through callbacks, and watching props)</li> <li>It could result in infinite recursion (since bindings can set props, they would trigger the
watch, which could update the bindings again).</li></ul> <p>So it's probably not a good idea to enable this.</p> <p>Then we have 2 related additional options, if we should update the HTML to reflect the
internal state of the component, and if we should update the props when any html (through
other means) is updated. Doing this could also result in recursion.
But more importantly, it would &quot;move&quot; the logic to keep using and mutating props in the
component, which is probably not good practice. So we'll ignore this for now.</p></li> <li><p><strong>Q:</strong> Do we need an &quot;adopted&quot; lifecycle hook? Would it trigger on Parent or Root adoption? Do we
need both? Should we &quot;delay&quot; the &quot;mount&quot; lifecycle hook? Of have &quot;created&quot;, &quot;mounted&quot; and
&quot;adopted&quot;?</p> <p><strong>A:</strong> Not sure, if we want to be extensive, we would have; setup(1), created(2), mounted(3) and
adopted(4). If we want to be minimal, we would have; setup(1) and mounted(4).</p> <p><strong>P:</strong> We have 3 &quot;moment&quot; in the creation process of a component. Since components are created as
part the parent creation, it's always &quot;completed&quot; earlier than the parent. This means we
have the moment where a component itself is created, we have the moment where its parent
is created as well (and we receive their props, e.g. callbacks), and we have the moment the
whole app is created (up to the root component).
In most cases, we only care about the component in isolation, so we can use the first one.
In some cases, we might need something from the parent (e.g. calling a function passed
through the props), which we can only do when the parent has been fully created.
And in other cases, we need access to the root, global state, etc to be set up correctly.</p> <p>Timing wise, these should all happen in the same frame, since the creation process is all
synchronous (it's just that other stuff happens in between).  We could just chose the have 1
hook (when the root has been created), and use that for everything.</p> <p>We already have the setup function itself, so the current &quot;mounted&quot; has not much additional
value in its current state. Only difference is that bindings are applied,
so manual DOM mutations will update correctly. It could be useful if we ever want to delay
child component creation to the &quot;applyBindings&quot; phase, and only have those instances
accessible in the mount hook.</p></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/muban/research/" class="prev router-link-active">
        Research
      </a></span> <span class="next"><a href="/muban/research/component-props.html">
        Component Props
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/muban/assets/js/app.48237296.js" defer></script><script src="/muban/assets/js/2.de8cd9c4.js" defer></script><script src="/muban/assets/js/25.33fc5c13.js" defer></script>
  </body>
</html>
